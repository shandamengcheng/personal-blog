# 网络相关

### 分层
1. 应用层
> 在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信。
发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过回送报文进行响
应。进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接收报文。 
> 无状态协议 HTTP => cookie, DNS

2. 运输层 eg: TCP, UDP
在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为
运输层报文段（segment） 。实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（即数据报）并向目的地发送。

### HTTP报文格式 （P.86 自顶向下）
- 请求报文：
  - 请求行： 方法， URL, 版本
  - 首部行： 首部字段名(空隔)值(换行)
  - 空行
  - 实体体 => post上传表单的数据等
- 响应报文
  - 状态行：版本（空格）状态码（空格）状态描述
  - 首部行： 首部字段名(空隔)值(换行)
  - 空行
  - 实体体

### 常见状态码
![](https://s.poetries.work/images/202202211654404.png)
> https://www.webfx.com/web-development/glossary/http-status-codes/what-is-a-100-status-code/

### TCP与UDP的区别
- TCP面向连接的，可靠数据传输，提供拥塞控制机制
- UDP 无连接的 => 减少了建立连接的时延，不可靠数据传输， 无拥塞控制机制
- UDP的首部是8个字节，TCP首部是20个字节
- UDP的传输速度快，比较适用于实时应用
- UDP无连接状态，不需要维护连接状态，TCP需要维护连接状态。此连接状态包括接收和发送缓存、
拥塞控制参数以及序号与确认号的参数。
- TCP是点对点的，UDP可以一对多

### HTTPS

### HTTP2与HTTP1的区别
> https://http2.github.io/faq/#what-are-the-key-differences-to-http1x

### DNS
> https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/

### CDN


### UDP
除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。实际上，如果应用程序开发人
员选择UDP而不是TCP,则该应用程序差不多就是直接与IP打交道。UDP从应用进程得
到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段,
然后将形成的报文段交给网络层。网络层将该运输层报文段封装到一个IP数据报中，然
后尽力而为地尝试将此报文段交付给接收主机。如果该报文段到达接收主机，UDP使用目
的端口号将报文段中的数据交付给正确的应用进程。值得注意的是，使用UDP时，在发
送报文段之前，发送方和接收方的运输层实体之间没有握手。正因为如此，UDP被称为是
无连接的
- 应用实例： DNS查询， P.149
- 报文结构：
  - 4个字段，每个字段两个字节组成。
  - ![](.\img\UDP报文结构.png)
  - 长度字段指示了在UDP报文段中的字节数（首部加数据）
  - 校验和：提供差错检验功能。UDP的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告。


### TCP
TCP是在不可靠的（IP）端到端网络层之上实现的可靠数据传输协议

客户进程通过sokcet传递数据流。数据一旦通过该门，它就由客户中的TCP控制了。TCP将这些数据引导在该连接的额发送缓存里，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据，并将数据传递到网络层。TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度。TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段（TCP segment）。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的接收缓存中。应用程序从此缓存中读取数据流。该连接的每一端都有各自的发送缓存和接收缓存。
![](.\img\TCP发送缓存.jpg)

- 序号seq: 该报文段首字节的字节流编号。
> 假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一
个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个
包含500 000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如图3・30
所示，该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0,第二个报文
段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP
报文段首部的序号字段中。
- 确认号ack: 主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。
> P.174

#### TCP三次握手
三次握手中，前两个报文不承载”有效载荷“，也就是不包含应用层的数据。第三个报文段可以承载有效载荷。

<hr />
过程：P.185

#### TCP四次挥手

P.185
#### 为什么客户端会有Time_wait
- 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；
- 保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息；
- > https://zhuanlan.zhihu.com/p/99943313
- > https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux