## 包管理工具

#### 什么是包

具有一定功能的程序称为包。包是可重用的软件，在我们进行程序开发时，可以从全局注册表下载到本地开发环境中。包可能依赖也可能不依赖其他包。包，在我们的项目中也佳作依赖项，项目要正常的执行，需要依赖

### 包管理器（是什么，为什么）

 包管理器提供新的依赖项（也称作： 包）的安装，管理包在文件系统上的存储位置，并提供给使用者自己发布包的能力。
当然，理论上也可以不使用包管理器，但是需要手动确认：
- 查找所有所有包的正确Javascript文件
- 确保这些包没有已知的漏洞
- 下载它们，并把它们放在项目中正确的位置
- 对这些包的子依赖项也执行上叙操作，可能有成百上千的子依赖项
- 如果你想删除某个包，移除其所有的文件  

另外，包管理器还处理重复的依赖项。

### 语义化版本
stackoverflow上有几个问题：  
https://stackoverflow.com/questions/22343224/whats-the-difference-between-tilde-and-caret-in-package-json  

语义化版本规则规定，版本格式为：主版本号.次版本号.修订号

```
"dependencies": {
    "antd": "3.1.2",
    "react": "~16.0.1",
    "redux": "^3.7.2",
    "lodash": "*"
  }

```
1. 3.1.2 表示确定的版本
2. ～: 表示只升级修订号，比如react@~16.0.1: >= react@16.0.1 && < react@16.1.0
3. ^：表示升级此版本号和修订号， 比如redux@^3.7.2: >=redux@3.7.2 && < redux@4.0.0
4. *：可以匹配任何版本

> 详细参看： https://github.com/npm/node-semver#versions  


### 依赖树的结构
#### 嵌套结构
[![HzxSYV.png](https://s4.ax1x.com/2022/02/22/HzxSYV.png)](https://imgtu.com/i/HzxSYV)
在npm v3.x之前，npm的依赖树结构为嵌套结构，如上图所示，npm处理依赖的关系很直接，通过递归的方式按照package.json中的依赖结构以及子依赖包的package.json的结构将依赖安装到它们各自的node_modules中，直到有子依赖包不再依赖其他模块。在嵌套依赖结构的情况下，每个依赖关系都可以在不同的名称空间中将其自身的依赖关系与其他依赖关系隔离。但是，包管理器需要遍历多个级别以解决依赖关系。而且还会导致：
1. 当嵌套层级过深的时候，多个相同的包会被重复下载，导致文件系统资源的浪费。
2. 在Windows系统中，文件路径的最大长度为260个字符，如果嵌套层级过深可能会导致不可预知的问题。

> 在window10的1607版本中，MAX_PATH已经从Win32文件和目录函数中删除了，但是也需要执行一些操作来启用长路径行为。https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=cmd

#### 扁平结构

为了解决上述问题，npm在v3.x版本修改了依赖树的结构，变成扁平结构。
> https://github.com/npm/npm/releases/tag/v3.0.0

[![bSVpfH.png](https://s4.ax1x.com/2022/02/22/bSVpfH.png)](https://imgtu.com/i/bSVpfH)
换成扁平结构之后，安装依赖时，<font color="red">优先安装在node_modules目录，不管是项目的依赖项还是依赖项的依赖项..... 以此类推. 
如果安装到相同模块时，判断已安装模块是符合新模块的版本范围，如果不符合，在当前模块的node_modules下安装该模块，如果符合则跳过。（也就是模块的依赖关系发生冲突时，才会产生嵌套的模块）</font>

### npm的几个重大阶段
#### npm v1
npm v1版本使用的嵌套结构，上面已经介绍过了，会造成嵌套过深和重复依赖存储多份的问题。

#### npm v3
v3相对于v1重点在于node_modules中的依赖结构发生的修改，从嵌套结构变成了扁平结构。虽然npm v3避免了依赖嵌套的问题，但是v3 引入了另一个问题：v3会解析依赖的多个版本为一个版本。假设A依赖 B@^1.0.1, D依赖B@^1.0.2， 如果先添加D的依赖，那么由于D依赖的B版本为两者交集里面，所以只会有一个B@^1.0.2被添加在同一个node_modules中。

假设项目中当前的依赖树的结构如下：
[![b9Zkvj.png](https://s4.ax1x.com/2022/02/23/b9Zkvj.png)](https://imgtu.com/i/b9Zkvj)

如果我们的依赖树中没有依赖base64-js@^1.0.1,那么会有两种情况：
1. 先依赖buffer:
[![b9lY4I.png](https://s4.ax1x.com/2022/02/23/b9lY4I.png)](https://imgtu.com/i/b9lY4I)
2. 先依赖buffer2:
[![bCCzG9.png](https://s4.ax1x.com/2022/02/23/bCCzG9.png)](https://imgtu.com/i/bCCzG9)

这里就存在一个问题，如果先依赖buffer2,node_modules中会添加包base64-js@1.0.3
由此就会导致一个最为人诟病的不确定性问题。  

#### npm v5
v3虽然解决了嵌套结构过深的问题，但是在改为扁平结构后，存在一个不确定性的问题，那么就可能导致一种情况，对于相同的package.json，不同的设备在npm install时，可以node_modules中的依赖版本有所不同。为了解决这种不确定性，v5中引入了package-lock.json文件，依赖的安装结构仍为v3.x中的扁平结构。  
```
{
  "name": "my-app",
  "version": "1.0.0",
  "dependencies": {
    "base64-js": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz",
      "integrity": "sha1-aSbRsZT7xze47tUTdW3i/Np+pAg="
    },
    "buffer": {
      "version": "5.4.3",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-5.4.3.tgz",
      "integrity": "sha512-zvj65TkFeIt3i6aj5bIvJDzjjQQGs4o/sNoezg1F1kYap9Nu2jcUdpwzRSJTHMMzG0H7bZkn4rNQpImhuxWX2A==",
      "requires": {
        "base64-js": "^1.0.2",
        "ieee754": "^1.1.4"
      },
      "dependencies": {
        "base64-js": {
          "version": "1.3.1",
          "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.3.1.tgz",
          "integrity": "sha512-mLQ4i2QO1ytvGWFWmcngKO//JXAQueZvwEKtjgQFM4jIK0kU+ytMfplL8j+n5mspOfjHwoAg+9yhb7BwAHm36g=="
        }
      }
    },
    "ieee754": {
      "version": "1.1.13",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.1.13.tgz",
      "integrity": "sha512-4vf7I2LYV/HaWerSo3XmlMkp5eZ83i+/CDluXi/IGTs/O1sejBNhTtnxzmRZfvOUqj7lZjqHkeTvpgSFDlWZTg=="
    },
    "ignore": {
      "version": "5.1.4",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.1.4.tgz",
      "integrity": "sha512-MzbUSahkTW1u7JpKKjY7LCARd1fU5W2rLdxlM4kdkayuCwZImjkpluF9CM1aLewYJguPDqewLam18Y6AU69A8A=="
    }
  }
}
```
上面为package-lock.json文件的一个例子，可以看到，该文件记录了依赖的确定版本，依赖的来源等信息，这样就确保了不同的设备安装生成的依赖目录（也就是node_modules目录结构）保持一致。

[![bCAZ0P.png](https://s4.ax1x.com/2022/02/23/bCAZ0P.png)](https://imgtu.com/i/bCAZ0P)


### lock文件
npm v5中引入的lock文件为package-lock.json文件。
[![bkzCK1.jpg](https://s4.ax1x.com/2022/02/25/bkzCK1.jpg)](https://imgtu.com/i/bkzCK1)  

### 缓存
 在执行npm install或npm update之后，除了会在node_modules中安装依赖包，也会在本地的缓存目录缓存目录。  
 通过npm config get cache可以查出本地的缓存目录的地址。在Mac或Linux下默认是用户主目录下的.npm/_cacache目录。
[![bA8PVP.png](https://s4.ax1x.com/2022/02/25/bA8PVP.png)](https://imgtu.com/i/bA8PVP)
通过ls命令可以查询到，在.npm下面有一个_cacache文件夹。这个文件夹就是存储npm缓存的地方。  
在_cacache目录下，可以查到三个文件：
```
~/.npm/_cacache ls
content-v2 index-v5   tmp
```
主要看content-v2 和 index-v5两个文件夹。 在content-v2中存储的是依赖的tar包，在index-v5中存储的是依赖包的索引信息。

- 先是通过 `grep {resolved} -r index-v5`获取到index-v5中的依赖包的索引信息。
> 比如： `grep "https://registry.npmjs.org/antd/-/antd-4.18.8.tgz" -r index-v5`  

- 会获取到如下信息：
```
{
	"key": "pacote:version-manifest:https://registry.npmjs.org/antd/-/antd-4.18.8.tgz:sha512-eT701hvqy3m7y06pfx6j0onsXOslym7+iNrTHH8cytzQd1Bbefc6Jm7deRnOqjEkSeZM5iJlw2SpBn1+0Cu+Ig==",
	"integrity": "sha512-C2EkHXwXvLsbrucJTRS3xFHv7Mf/y9klmKDxPTE8yevCoH5h8Ae69Y+/lP+ahpW91crnzgO78elOk2E6APJfIQ==",
	"time": 1645587211520,
	"size": 1,
	"metadata": {
		"id": "antd@4.18.8",
		"manifest": {
			"name": "antd",
			"version": "4.18.8",
			"dependencies": {
			...
			},
			"optionalDependencies": {},
			"peerDependenciesMeta": {},
			"devDependencies": {
				...
			},
			"bundleDependencies": false,
			"peerDependencies": {
				"react": ">=16.9.0",
				"react-dom": ">=16.9.0"
			},
			"deprecated": false,
			"_resolved": "https://registry.npmjs.org/antd/-/antd-4.18.8.tgz",
			"_integrity": "sha512-eT701hvqy3m7y06pfx6j0onsXOslym7+iNrTHH8cytzQd1Bbefc6Jm7deRnOqjEkSeZM5iJlw2SpBn1+0Cu+Ig==",
			"_shasum": "abd7a54790311c7ced41123cf9f96e47582c629b",
			"_shrinkwrap": null,
			"_id": "antd@4.18.8"
		},
		"type": "finalized-manifest"
	}
}
```
- 通过里面的_shasum可以获取到content-v2中的tar包的信息
> 如果通过 `grep {_shasum} -r content-v2`的方式，会展示出文件的细节，第一行会展示出文件的tar在content-v2中的具体目录

### npm install流程
- 检查.npmrc文件，优先级为：项目级的.npmrc文件 > 用户级的.npmrc文件 > 全局级的.npmrc文件 > npm内置的.npmrc文件  

  1. 项目级别的.npmrc文件：在项目的根目录下创建一个.npmrc文件，只用于管理这个项目的npm安装
  2. 用户级别的.npmrc文件：在使用一个账户登陆电脑的时候，可以为当前用户创建一个.npmrc文件，之后使用该用户登陆电脑，可以使用该配置文件。获取文件的位置方式： `npm config get userconfig`
  3. 全局级别的.npmrc文件：一个电脑可能有多个用户，在多个用户之上，可以创建一个公共的.npmrc文件供所有用户使用。获取路径命令：`npm config get globalconfig`
  4. npm内置的.npmrc文件：不可修改的内置文件，基本用不到
> .npmrc文件的主要作用是帮助开发者安装需要的依赖包，可定义包从哪里下载，哪个版本，下载到电脑的哪个路径下，常见的如`registry=https://registry.npm.taobao.org`，定义包的下载来源。
- 检查有无lock文件
- 无lock文件
  - 从npm远程仓库获取包信息
  - 根据package.json文件构建依赖树，过程如下：
    - 构建依赖树时，不管是直接依赖还是依赖的依赖，优先将其放在node_modules根目录。
    - 当遇到相同的模块时，判断node_modules根目录下的模块版本是否符合新模块的范围，如果符合，则跳过。不符合的话，在当前模块的node_modules下添加该模块。
    - <font color="orange">上面的过程只是确定逻辑上的依赖树，并非真正的安装，后面会根据该逻辑树的结构去下载或从缓存中获取依赖包</font>
  - 在缓存中依次查找依赖树中的每个包：
    - 不存在缓存：
      - 从npm远程仓库下载包
      - 校验包的完整性
      - 校验不通过：重新下载
      - 校验通过:
        - 将下载的包复制到npm缓存目录
        - 将下载的包按照结构解压到相应的node_modules
    - 存在缓存： 将缓存按照逻辑依赖树的结构解压到node_modules
  - 生成lock文件
- 有lock文件
  - 检查package.json文件中的依赖版本是否和package.json中的依赖有所冲突
  - 没有的话，查找缓存，...后续相同，有的话，过程同无lock文件

[![bKsRsg.png](https://s4.ax1x.com/2022/02/28/bKsRsg.png)](https://imgtu.com/i/bKsRsg)

### yarn 
> 可以看看facebook工程师对于yarn的介绍： https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/

Yarn发布于2016年，当时npm还没有到v5版本，但是npm v4还没有发布（https://github.com/npm/npm/releases?page=6 ）,那么这时候的npm还存在一致性的问题，然后在安全性和性能方面也存在着一定的问题，因此，facebook推出了自己的包管理工具：yarn.
### yarn install流程
1. 解析：Yarn通过向注册表发出请求并递归查找每个依赖项来开始解析依赖项
2. 获取：Yarn会在全局缓存目录中查找依赖包是否已经被下载。如果没有下载，Yarn会获取压缩文件并把它放在全局缓存中，这样，可以在离线时正常工作，而且也不用再次下载依赖。依赖包也可以以压缩包的形式放在源代码管理中，以进行完整的离线安装。
3. 链接：最后，Yarn将所有需要的文件从全局缓存中复制到本地node_modules目录中，从而将所有的内容链接在一起。

### yarn.lock与package-lock.json比较

### pnpm


#### 参考文献
- https://segmentfault.com/a/1190000021305625#item-4-14
- https://www.zhihu.com/question/305539244/answer/551386426
- https://juejin.cn/post/6844903552012255245#heading-6
